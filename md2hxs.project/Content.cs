using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text.RegularExpressions;
using System.Xml.Linq;
using HtmlAgilityPack;

namespace md2hxs
{
    /// <summary>
    /// A helper class that cleans files before and after conversion and applies MSTP formatting requirements.
    /// </summary>
    internal static class Content
    {
        /// <summary>
        /// Prepares markdown files for conversion by Pandoc.exe.
        /// </summary>
        /// <param name="filePath">The full path to the source markdown file.</param>
        /// <returns>The temporary file path for the cleaned markdown file that will be converted into html.</returns>
        internal static string preClean(string filePath)
        {
            string content = File.ReadAllText(filePath);

            // Remove key value pairs.
            string pattern = @"<!--\r\n(\w+ : \S+.*?\r\n)+?-->";
            content = Regex.Replace(content, pattern, "", RegexOptions.Singleline);

            // Replace markdown-escaped characters with html-escaped characters
            content = Regex.Replace(content, @"\\<", "&lt;", RegexOptions.Singleline);
            content = Regex.Replace(content, @"\\>", "&gt;", RegexOptions.Singleline);

            // Derive temporary file path.
            string tempPath = Program.OutputDirectoryPath + "\\" + Path.GetFileName(filePath) + ".clean";

            // Save to temporary file.
            if (!Utils.tryWrite(tempPath, content)) return "";

            return tempPath;
        }

        /// <summary>
        /// Edits html content generated by Pandoc.exe to update link and image paths and meet MTPS requirements.
        /// </summary>
        /// <param name="MsHelp">The MTPS metadata for the file.</param>
        /// <param name="title">The title of the document.</param>
        /// <param name="body">The contents of the <body /> tag in the generated html content.</param>
        /// <param name="outputFileName">The full path to where the finished html file will be written.</param>
        /// <returns>The completed html content as a string.</returns>
        internal static string postClean(XElement MsHelp, string title, string body, string outputFileName)
        {
            // Insert standard HEAD element with title and metadata block, and remove namespace declaration from xml block..
            string head = string.Format(HEAD_BASE, title, MsHelp.ToString())
                .Replace(" xmlns:MSHelp=\"http://msdn.microsoft.com/mshelp\"", "");

            // Restore ">" characters converted by pandoc.
            //body = Regex.Replace(body, "&gt;", @">", RegexOptions.Singleline);

            //////////// HTML DOM fixes here ////////////////////

            // Convert internal links to flat folder hierarchy.
            HtmlDocument doc = new HtmlDocument();
            doc.LoadHtml(body);
            HtmlNode[] anchors = doc.DocumentNode.Descendants("a").ToArray<HtmlNode>();     // anchors is the list of "a" elements in the html doc
            int failures = 0;
            for (int i = anchors.Length - 1; i > -1; i--)
            {
                if (!anchors[i].Attributes.Contains("href")) continue;
                string originalLink = undoEscapes(anchors[i].Attributes["href"].Value);
                if (originalLink.StartsWith("http://") || originalLink.StartsWith("https://")
                    || originalLink.StartsWith("www.") || originalLink.StartsWith("#")
                    || !Uri.IsWellFormedUriString(originalLink, UriKind.RelativeOrAbsolute)) continue;     // Skip non-linking anchors, invalid, and external links.
                string sourceFileName = Path.GetFileNameWithoutExtension(outputFileName);
                if (!Program.TOC.FileMap.ContainsValue(sourceFileName)) continue;
                Uri oldSource = new Uri(Program.TOC.FileMap.First(kvp => kvp.Value == sourceFileName).Key);

                Uri targetUrl = new Uri(oldSource, originalLink);
                string targetPath = Regex.Replace(targetUrl.LocalPath, @"(.*)(\.\w+)", "$1.md");
                string linkName = "";
                if (!Program.TOC.FileMap.TryGetValue(targetPath, out linkName))
                {
                    File.AppendAllText(Program.LogPath, string.Format("Failed to resolve link to {1} in {0}.\r\n", oldSource, originalLink));
                    failures++;
                    anchors[i].Attributes["href"].Value = (originalLink.Contains(".."))
                        ? originalLink.Substring(originalLink.LastIndexOf("..")) : originalLink;
                }
                else anchors[i].Attributes["href"].Value = (linkName == "") ? "" : linkName + ".htm";
            }
            if (failures > 0) Console.WriteLine("md2hxs found {0} relative links that could not be resolved. See {1} for details.", failures, Program.LogPath);

            // Update image links.
            HtmlNode[] images = doc.DocumentNode.Descendants("img").ToArray<HtmlNode>();     // images is the list of "img" elements in the html doc
            for (int i = images.Length - 1; i > -1; i--)
            {
                string s = images[i].GetAttributeValue("src", "none");
                if (s.StartsWith("http://") || s.StartsWith("www.") || s == "none") continue;     // Skip non-linking images and external links.
                images[i].SetAttributeValue("src", Path.GetFileName(s));
            }

            // Format code blocks for MTPS.
            HtmlNode[] tables = doc.DocumentNode.Descendants("table").ToArray<HtmlNode>();     // images is the list of "table" elements in the html doc
            for (int i = tables.Length - 1; i > -1; i--)
            {
                if (tables[i].Descendants("pre").Count() > 0)
                    tables[i].ParentNode.ReplaceChild(applyCodeColoring(tables[i], outputFileName), tables[i]);
            }
            HtmlNode[] pres = doc.DocumentNode.Descendants("pre").ToArray<HtmlNode>();     // images is the list of "table" elements in the html doc
            for (int i = pres.Length - 1; i > -1; i--)
            {
                if (pres[i].Ancestors("table").Count() == 0 && pres[i].ParentNode != null)
                    pres[i].ParentNode.ReplaceChild(applyCodeColoring(pres[i], outputFileName), pres[i]);
            }
            
            //Remove duplicate spans from tops of code blocks.
            HtmlNode[] spans = doc.DocumentNode.Descendants("span").ToArray<HtmlNode>();
            for (int i = spans.Length - 1; i >= 0; i--)
            {
                if (spans[i].GetAttributeValue("class", "") == "copyCode")
                    if (spans[i].NextSibling != null || spans[i].ParentNode.Name != "th")
                        spans[i].Remove();
            }

            body = doc.DocumentNode.OuterHtml;

            ///////////// Text-based fixes here //////////////////

            // Replace escaped angle brackets with character codes.
            if (Regex.IsMatch(body, @"\\<([\w ]*)\\>", RegexOptions.Singleline))
            {
                body = Regex.Replace(body, @"\\<([\w ]*)\\>", "&lt$1&gt", RegexOptions.Singleline);
            }

            // Combine and return.
            return string.Format("{0}\r\n<body>\r\n{1}\r\n</body>\r\n</html>",
                head, body);
        }

        /// <summary>
        /// Surrounds code blocks with the necessary markup to get syntax highlighting from MTPS.
        /// Code blocks authored in Markdown must match the following format:
        /// (language specifier)
        /// ```
        /// (code)
        /// ```
        /// There must not be anything between the language specifier and the first set of backticks except a single empty line.
        /// Code authored in HTML may appear as:
        /// <p>(language specifier)</p><pre><code>(code)</code></pre> with nothing between the language paragraph and the <pre> tag, --OR--
        /// <table><tr><th>(language)</th></tr><tr><td><pre>(code)</pre></td></tr></table> as long as the language specifier appears before the code in the same table and there is only one language and one code block per table.
        /// </summary>
        /// <param name="node">The html <PRE> element that contains the code to display, or a table that contains exactly one <pre> element.</param>
        /// <param name="outputFileName">The name of the file being written to.</param>
        /// <returns></returns>
        private static HtmlNode applyCodeColoring(HtmlNode node, string outputFileName)
        {
            // Determine the code language.
            string langVal = "", langKey = "";
            bool isTable = node.Name == "table";
            var prev = node.PreviousSibling;
            if (!isTable) while (prev != null && !Regex.IsMatch(prev.InnerText, @"\S"))
                    prev = prev.PreviousSibling;  // Walk back until we find non-whitespace characters.
            if (prev != null)
            {
                string content;
                if (isTable) content = node.InnerText;  // Move this up out of the loop
                else content = (prev != null) ? prev.InnerText : "";
                RegexOptions options = RegexOptions.IgnoreCase | RegexOptions.Singleline;
                foreach (string key in CodeLangs.Keys)
                {
                    foreach (string val in CodeLangs[key])
                    {
                        //string pattern = (isTable) ? @"^\s*(" + val + @")\s*$" : @"^.*>\s*(" + val + @")\s*<.*pre>" ;
                        string pattern = (isTable) ? @"^\s*(" + val + @")\s*$" : @"^\s*(" + val + @")\s*$";
                        Match m = Regex.Match(content, pattern, options);
                        if (m.Captures.Count > 0)
                        {
                            langKey = key;
                            langVal = m.Groups[1].Value;
                            break;
                        }
                    }
                    if (langVal != "") break;
                }
            }

            if (langVal == "") Utils.tryWrite(Program.LogPath, string.Format(
                        "File {0} contains a code block with no recognized language specifier.\r\n", Program.OutputDirectoryPath + "\\" + outputFileName), true, false);

            // Remove the node that was the language specifier.
            if (!isTable && langKey != "") prev.Remove();

            // Return the replacement node.
            HtmlNode wrappedNode = node.OwnerDocument.CreateElement("div");
            string pre = (isTable) ? node.Descendants("pre").First().OuterHtml : node.OuterHtml;
            wrappedNode.InnerHtml = string.Format(CODE_BLOCK, langKey, langVal, pre);
            return wrappedNode.FirstChild;
        }

        private static string undoEscapes(string s) { return s.Replace("&#39;", "'"); }

        static Dictionary<string, string[]> CodeLangs = new Dictionary<string, string[]>() 
        {
            { "ManagedCPlusPlus", new string[] { @"cpp#?", @"c", @"c\+\+" }},
            { "CSharp", new string[] { @"C#", @"cs", @"\[?c#\]?" }},
            { "JScript", new string[] {"js", @"jscript#?", "javascript" }},
            { "JSharp", new string[] {@"j#", "jsharp"}},
            { "Visual Basic", new string[] { @"vb#?", @"\[?visual( |\&#160)basic\]?" }},
            { "VBScript", new string[] {"vbs"}},
            { "xml", new string[] {"xml"}},
            { "xaml", new string[] {"xaml"}},
            { "html", new string[] {"html"}}
        };

        /// <summary>
        /// Standard HTML block to insert code as formatted string. {0} is code language attribute, {1} is displayed code language, {2} is the code to insert.
        /// </summary>
        const string CODE_BLOCK = "<div class=\"code\">\r\n<span codeLanguage=\"{0}\">\r\n\t<table width=\"100%\" cellspacing=\"0\" cellpadding=\"0\">\r\n\t\t<tr>\r\n\t\t\t<th>{1}</th>"
                + "\r\n\t\t\t<th>\r\n\t\t\t\t<span class=\"copyCode\" onclick=\"CopyCode(this)\" onkeypress=\"CopyCode_CheckKey(this)\" onmouseover=\"ChangeCopyCodeIcon(this)\""
                + "onfocusin=\"ChangeCopyCodeIcon(this)\" onmouseout=\"ChangeCopyCodeIcon(this)\" onfocusout=\"ChangeCopyCodeIcon(this)\" tabindex=\"0\">"
                + "\r\n\t\t\t\t\t<img class=\"copyCodeImage\" name=\"ccImage\" align=\"absmiddle\" src=\"copycode.gif\"></img>Copy Code</span>"
                + "\r\n\t\t\t\t</th>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td colspan=\"2\">{2}</td>\r\n\t\t\t</tr>\r\n\t\t</table>\r\n\t</span>\r\n</div>";

        /// <summary>
        /// Standard HTML block to insert HEAD element as formatted string. {0} is code title attribute, {1} is the metadata XML island.
        /// </summary>
        const string HEAD_BASE = "<html xmlns:MSHelp=\"http://msdn.microsoft.com/mshelp\" xmlns:msxsl=\"urn:schemas-microsoft-com:xslt\" xmlns:xanx=\"http://schemas.microsoft.com/developer/xanx/2005\">"
                + "\r\n<head>\r\n<meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" />\r\n<meta name=\"save\" content=\"history\" />"
                + "<title>{0}</title>\r\n<link rel=\"stylesheet\" type=\"text/css\" href=\"xanx.css\" />\r\n<link rel=\"stylesheet\" type=\"text/css\" href=\"HxLink.css\" />"
                + "\r\n<script src=\"script.js\"> </script>\r\n{1}</head>";
    }
}
